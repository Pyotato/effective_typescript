# 🥰 ITEM 46 : 타입 선언과 관련된 세 가지 버전 이해하기

의존성 관리는 개발자에게 매우 힘든 일입니다.
그래서 여러분은 아마 단순히 라이브러리를 프로젝트에 추가해서 사용할 뿐이지 라이브러리의 전이적 (transitive) 의존성이 호환되는지 깊게 생각하지 않습니다.

그런데 실제로 타입스크립트는 알아서 의존성 문제를 해결해 주기는 커녕, 의존성 관리를 오히려 더 복잡하게 만듭니다.
왜냐하면 타입스크립트를 사용하면 다음 세 가지 사항을 추가로 고려해야 하기 때문입니다.

<div id="three_versions">
  <ul>
    <li> 라이브러리의 버전 </li>
     <li> 타입 선언 (`@types`) 버전 </li>
     <li> 타입스크립트의 버전</li>
  </ul>
</div>

세 가지 버전 중 하나라도 맞지 않으면, 의존성과 상관없이 보이는 곳에서 엉뚱한 오류가 발생할 수 있습니다.
이렇게 발생한 오류의 원인을 파악하고 고치기 위해서는 타입스크립트 라이브러리 관리의 복잡한 메커니즘을 모두 이해해야 합니다.
라이브러리 관리의 메커니즘을 이해하게 된다면 프로젝트 내에서 작성한 타입 선언을 외부에 공개해야 하는 시점이 되었을 때, 버전과 관련해서 제대로 된 결정을 내릴 수 있습니다.

타입스크립트에서 일반적으로 의존성을 사용하는 방식은 다음과 같습니다.
특정 라이브러리를 dependencies로 설치하고, 타입 정보는 depDependencies로 설치합니다 ([아이템 45](https://github.com/Pyotato/effective_typescript/blob/item45/README.md)). 

> $ npm install react <br/>
> react@16.8.6 <br/>
> $ npm install --save-dev @types/react <br/>
> @types/react@16.8.19

메이저 버전과 마이너 버전(16.8)이 일치하지만 패치 버전(.6과 .9)은 일치하지 않는다는 점에 주목하길 바랍니다.
`@types/react`의 16.8.19는 타입 선언들이 리액트 16.8 버전의 API를 나타낸다는 것을 의미합니다.
만약 리액트 모듈이 [시맨틱 (semantic) 버전 규칙](https://semver.org/lang/ko/)을 제대로 지킨다고 가정하면 패치 버전들 (16.8.1, 16.8.2, ...)을 공개 API의 사양을 변경하지 않습니다. 
따라서 타입 선언을 업데이트할 필요가 없습니다.
그러나 타입 선언 자체에도 버그나 누락이 존재할 수 있으며 `@types` 모듈의 패치 버전은 버그나 누락으로 인한 수정과 추가에 따른 것입니다. 
앞선 예제의 경우 라이브러리 자체보다 타입 선언에 더 많은 업데이트가 있습니다 (19 대 6).

그러나 실제 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식은 다음 네 가지 문제점이 있습니다.

> 🫤 첫 번째, 라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트하지 않는 경우입니다.

이런 경우 라이브러리 업데이트와 관련된 새로운 기능을 사용하려 할 때마다 타입 오류가 발생하게 됩니다. 특히 하위 호환성이 깨지는 변경이 있었다면, 코드가 타입 체커를 통과하더라도 런타임에 오류가 발생할 수 있습니다.

일반적인 해결책은 타입 선언도 업데이트하여 라이브러리와 버전을 맞추는 것입니다.
그러나 업데이트해야 할 타입 선언의 버전이 아직 준비도지 않은 경우라면 두 가지 선택지가 있습니다.
보강(augumentation) 기법을 활용하여, 사용하려는 새 함수와 매서드의 타입 정보를 프로젝트 자체에 추가하는 것입니다.
또는 타입 선언의 업데이트를 직접 작성하고 공개하여 커뮤니티에 기여하는 방법도 있습니다.

> 🫤 두 번째, 라이브러리보다 타입 선언의 버전이 최신인 경우입니다.

이런 경우는 타입 정보 없이 라이브러리를 사용해 오다가 (아마도 `declare module`을 사용해서 `any`타입으로 사용했을 겁니다) 타입 선언을 설치하려고 할 때 뒤늦게 발생합니다. 
그 사이에 라이브러리와 타입 선언의 새 버전이 릴리스되었다면 타이브러리와 타입 선언의 버전 정보는 어긋나게 될 것입니다.
첫 번째 문제와 상황ㅇ이 비슷하지만 버전의 대소 관계가 반대입니다. 
타입 체커는 최신 API를 기준으로 코드를 검사하게 되지만 런타임에 실제로 쓰이는 것은 과거 버전입니다. 
해결책은 라이브러리와 타입 선언의 버전이 맞도록 라이브러리 버전을 올리거나 타입 선언의 버전을 내리는 것입니다. 

> 🫤 세 번째, 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입스크립트 버전이 최신인 경우입니다,

일반적으로 로대시(Lodash), 리액트 (React), 람다 (Ramda) 같은 유명 자바스크립트 라이브러리의 타입 정보를 더 정확하게 표현하기 위해서 타입스크립트에서 타입 시스템이 개선되고 버전이 올라가게 됩니다.
그러므로 이러한 라이브러리들의 최신 타입 정보를 얻기 위해서라면 당연히 타입스크립트의 최신 버전을 사용해야 합니다.

현재 프로젝트보다 라이브러리에게 필요한 타입스크립트 버전이 높은 상황이라면, `@types`선언 자체에서 타입 오류가 발생하게 됩니다.
이 오류를 해결하려면 프로젝트의 타입스크립트 버전을 올리거나, 라이브러리 타입 선언의 버전을 원래대로 내리거나, `declare module` 선언으로 라이브러리의 타입 정보를 없애 버리면 됩니다.
`declare module` 선언응로 라이브러리의 타입 정보를 없애 버리면 됩니다.
라이브러리에서 typesVersions를 통해 타입스크립트 버전별로 다른 타입 선언을 제공하는 바업ㅂ도 있지만 실제로는 매우 드뭅니다. 
최근까지도 `DefinitelyTyped`의 라이브러리들 중 1% 미만에서만 `typesVersion`을 제공합니다.

타입스크립트의 특정 버전에 대한 타입 정보를 설치하려면 다음처럼 실행하면 됩니다. 

> $ npm install --save-dev @types/lodash@ts3.1

라이브러리와 타입 선언의 버전을 일치시키는 것이 최선이겠지만, 상황에 따라 해당 버전의 타입 정보가 없을 수도 있습니다.
그러나 유명한 라이브러리일수록 버전별로 타입 선언이 존재할 가능성이 높습니다.

> 🫤 네 번째, `@types` 의존성이 중복될 수도 있습니다.

`@types/foo`와 `@types/bar`에 의존하는 경우를 가정해 봅시다.
만약 `@types/bar`가 현재 프로젝트와 호환되지 않는 버전의 `@types/foo`에 의존한다면 npm은 중첩된 폴더에 별도로 해당 버전을 설치하여 문제를 해결하려고 합니다.

```
node_modules/
  @types/
    foo/
      index.d.ts @1.2.3
    bar/
      index.d.ts
        node_modules/
          @types/
            foo/
              index.d.ts @2.3.4
```

런타임에 사용되는 모듈이라면 괜찮을 수 있지만, 전역 네임스페이스 (name=space)에 있는 타입 선언 모듈이라면 대부분 문제가 발생합니다.
전역 네임스페이스에 타입 선언이 존재하면 중복된 선언, 또는 선언이 병합될 수 없다는 오류로 나타나게 됩니다.
이런 상황이라면 `npm ls @types/foo`를 실행하여 어디서 타입 선언 중복이 발생했는지 추적할 수 있습니다.
해결책은 보통 `@types/foo`을 업데이트하거나 `@types/bar`를 업데이트해서 서로 버전이 호환되게 하는 것입니다.
그러나 `@types`이 전이(transitive)의존성을 가지도록 만드는 것은 종종 문제를 일으키기도 합니다.
만약 타입 선언을 작성하고 공개하려고 한다면, [아이템 51](https://github.com/Pyotato/effective_typescript/blob/item51/README.md)을 참고하여 이러한 문제를 피하기 바랍니다.

일부 라이브러리, 특히 타입스크립트로 작성된 라이브러리들은 자체적으로 타입 선언을 포함(번들링, bundling)하게 됩니다.
자체적인 타입 선언은 보통 <i>package.json</i>의 "types"필드에서 <i>.d.ts</i> 파일을 가리키도록 되어 있습니다.

```json
{
  "name": "left-pad",
  "version": "1.3.0",
  "description": "String left pad",
  "main": "index.js",
  "types": "index.d.ts",
  // ...
}
```

`"types": "index.d.ts"` 를 추가하면 모든 문제가 해결될까요? 

번들링하여 타입 선언을 포함하는 경우, 특히 라이브러리가 타입스크립트로 작성되고 컴파일러를 통해 타입 선언이 생성된 경우라면 버전 불일치 문제를 해결하기는 합니다.
그러나 번들링 방식은 부수적인 네 가지 문제점을 가지고 있습니다.

> 😢 첫 번째, 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는 잘 동작헀지만 타입스크립트 버전잉 올라가면서 오류가 발생하는 경우에 문제가 됩니다.

`@types`을 별도로 사용하는 경우라면 라이브러리 자체의 버전에 맞추어 선택할 수 있습니다.
그러나 번들된 타입에서는 `@types`의 버전 선택이 불가능합니다.
단 하나의 잘못된 타입 선언으로 인해 타입스크립트의 버전을 올리지 못하는 불상사가 생길 수 있는 것입니다.
번들된 타입과 `DefinitelyTyped`이 비교되는 부분입니다.
마이크로소프트는 타입스크립트 버전이 올라감에 따라 `DefinitelyTyped`의 모든 타입 선언을 점검하며, 문제가 발견된 곳은 빠른 시간 내에 해결하고 있습니다.

> 😢 두 번쨰, 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존한다면 문제가 됩니다.

보통은 의존성이 devDependencies에 들어갑니다 ([아이템 45](https://github.com/Pyotato/effective_typescript/blob/item45/README.md)).
그러나 프로젝트를 공개하여 다른 사용자가 설치하게 되면 devDependencies가 설치되지 않을 것이고 타입 오류가 발생하게 됩니다.
반면 자바스크립트가 사용자 입장에서는 `@types`를 설치할 이유가 없기 때문에 dependencies에 포함하고 싶지 않을 겁니다. 
[아이템 51](https://github.com/Pyotato/effective_typescript/blob/item51/README.md)에서는 이러한 상황에 대한 표준 해결책을 다룹니다.
한편 `DefinitelyTyped`에 타입 선언을 공개하는 경우라면 첫 번째 상황은 전혀 문제가 되지 않습니다.
타입 선언은 `@types`에 있을 것이고 타입스크립트 사용자만이 타입 정보를 사용하게 됩니다.

> 😢 세 번째, 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우에는 과거 버전으로 돌아가서 패치 업데이트를 해야 합니다.

번들링된 타입 선언에서는 어려운 일이지만, `DefinitelyTyped`는 동일 라이브러리의 여러 버전의 타입 선언을 동시에 유지보수할 수 있는 메커니즘을 가지고 있습니다.  

> 😢 네 번쨰, 타입 선언의 패치 업데이트를 자주 하기 어렵다는 문제가 있습니다.

이번 아이템의 처음에 있던 `react`와 `@types/react` 버전의 사례를 떠올려봅시다.
라이브러리 자체보다 타입 선언에 대한 패치 업데이트가 무려 세 배나 더 많았습니다. 
`DefinitelyTyped`는 커뮤니티에서 관리되기 때문에 이러한 작업량을 감당할 수 있습니다.
만약 어떤 라이브러리의 유지 보수 담당자가 5일 이내 패치를 적용하지 않는 것으로 보인다면, 전체 유지보수 담당자가 패치를 하게 됩니다.
그러나 개별 프로젝트에서는 비슷한 처리 시간을 보장하기 어렵습니다.

타입스크립트에서 의존성을 관리한다는 것은 쉽지 않은 일이지만, 잘 관리한다면 그에 따른 보상이 함께 존재합니다.
잘 작성된 타입 선언은 라이브러리를 올바르게 사용하는 방법을 배우는 데 도움이 되면 생산성 역시 크게 향상 시킬 수 있습니다.
만약 의존성 관리에 문제가 생긴다면 이번 아이템의 처음에 언급했던 [세가지 버전](https://github.com/Pyotato/effective_typescript/blob/item46/README.md#three_versions)을 기억해야 합니다.

라이브러리를 공개하려는 경우, 타입 선언을 자체적으로 포함하는 것과 타입 정보만 분리하여 `DefinitelyTyped`에 공개하는 것의 장단점을 비교해 봐야 합니다.
공식적인 권장사항은 라이브러리가 타입스크립트로 작성된 경우만 타입 선언을 라이브러리에 포함하는 것입니다.
실제로 타입스크립트 컴파일러가 타입 선언을 대신 생성해 주기 때문에, 타입스트크립트로 작성된 라이브러리에 타입 선언을 포함하는 방식은 잘 동작합니다 (declaration 컴파일러 옵션을 사용).
자바스크립트로 작성된 라이브러리라면 손수 타입 선언은 오류가 있을 가능성이 높고 잦은 업데이트가 필요하게 됩니다.
자바스크립트로 작성된 라이브러리는 타입 선언을 `DefinitelyTyped`에 공개하여 커뮤니티에서 관리하고 유지보수하도록 맡기는 것이 좋습니다.
