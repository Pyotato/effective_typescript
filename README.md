# effective_typescript

## Contents

### 1장 : 타입스크립트 알아보기

>

| item |                                                  title                                                  | summary                                                                                                                                                                                                                                                                                             |
| :--: | :-----------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------ |
|  1  | [타입스크립트와 자바스크립트의 관계 이해하기](https://github.com/Pyotato/effective_typescript/blob/item1/README.md) | 💡 타입스크립트는 자바스크립트의 상위집입니다. 다시 말해서, 모든 자바스크립트 프로그램은 이미 타입스크립트 프로그램입니다. 반대로, 타입스크립트는 별도의 문법을 가지고 있기 떄문에 일반적으로는 유효한 자바스크립트 프로그램이 아닙니다. <br/> 💡 타입스크립트는 자바스크립트 런타임 동작을 모델링하는 타입 시스템을 가지고 있기 떄문에 런타임 오류를 발생시키는 코드를 찾아내려고 합니다. 그러나 모든 오류를 찾아내리라 기대하면 안됩니다. 타입체커를 통과하면서도 런타임 오류를 발생시키는 코드는 충분히 존재할 수 있습니다.  <br/> 💡 타입스크립트 타입 시스템은 전반적으로 자바스크립트 동작을 모델링합니다. 그러나 잘못된 매개변수 개수로 함수를 호출하는 경우처럼, 자바스크립트에서는 허용되지만 타입스크립트에서는 문제가 되는 경우도 있습니다. 이러한 문법의 엄격함은 온전히 취향의 차이이며 우열을 가릴 수 없는 문제입니다.                                                                                       |
|  3  | [코드 생성과 타입이 관계없음을 이해하기](https://github.com/Pyotato/effective_typescript/blob/item3/README.md) | 💡 코드 생성은 타입 시스템과 무관합니다. 타입스크립트 타입은 런타임 동작이나 성능에 영향을 주지 않습니다. <br/> 💡 타입  오류가 존재하더라도 코드 생성(컴파일)은 가능합니다. <br/> 💡 타입스크립트 타입은 런타임에 사용할 수 없습니다. 런타임에 타입을 지정하려면, 타입 정보를 위한 별도의 방법이 필요합니다. 일반적으로는 태그된 유니온과 속성 체크 방법을 사용합니다. 또는 클래스 같이 타입스크립트 타입과 런타임 값, 둘 다 제공하는 방법이 있습니다.                                                                        |
|  4  | [구조적 타이핑에 익숙해지기](https://github.com/Pyotato/effective_typescript/blob/item4/README.md) | 💡 자바스크립트가 덕 타이핑(duck typing) 기반이고 타입스크립트가 이를 모델링하기 위해 구조적 타이핑을 사용함을 이해해야합니다. 어떤 인터페이스에 할당 가능한 값이라면 타입 선언에 명시적으로 나열된 속성들을 가지고 있을 겁니다. 타입은 '봉인'되어 있지 않습니다. <br/> 💡 클래스 역시 구조적 타이핑 규칙을 따른다는 것을 명심해야 합니다. 클래스의 인스턴스가 예상과 다를 수 있습니다.  <br/> 💡구조적 타이핑을 사용하면 유닛 테스팅을 손쉽게 할 수 있습니다.  |
|  5  | [any 타입 지양하기](https://github.com/Pyotato/effective_typescript/blob/item5/README.md) | 💡 any 타입을 사용하면 타입 체커와 타입스크립트 언어 서비스를 무력화시켜 버립니다. any 타입은 진짜 문제점을 감추며, 개발 경험을 나쁘게 하고, 타입 시스템의 신뢰도를 떨어뜨립니다. 최대한 사용을 피하도록 합시다. | 


### 2장 : 타입스크립트의 타입 시스템

> 타입스크립트는 코드를 자바스크립트로 변환하는 역할도 하지만 [(아이템 3)](https://github.com/Pyotato/effective_typescript/blob/item3/README.md), 가장 중요한 역할은 타입 시스템에 있습니다.<br/>
> 타입스크립트를 사용하는 진정한 이유이기도 합니다.<br/>
> 2장에서는 타입 시스템의 기초부터 살펴봅니다. 타입 시스템이란 무엇인지, 어떻게 사용해야 하는지, 무엇을 결정해야 하는지, 가급적 사용하지 말아야할 기능은 무엇인지 알아봅니다.<br/>
> 타입스크립트의 타입 시스템은 매우 강력하며, 생각보다 더 많은 것을 할 수 있습니다. 2장의 아이템들은 타입스크립트 코드를 작성할 때, 그리고 이 책의 나머지를 읽을 때 필요한 개념의 견고한 토대를 마랸해 줄 겁니다.<br/>

| item |                                                  title                                                  | summary                                                                                                                                                                                                                                                                                             |
| :--: | :-----------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------ |
|  7  | [타입이 값들의 집합이라고 생각하기](https://github.com/Pyotato/effective_typescript/blob/item7/README.md) | 💡 타입을 값의 집합으로 생각하면 이해하기 편합니다(타입의 '범위'). 이 집합은 유한(boolean 또는 리터럴 타입)하거나 무한(number 또는 string)합니다. <br/> 💡 타입스트립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합 (벤 다이어그램)으로 표현 됩니다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있습니다. <br/> 💡 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있습니다. <br/> 💡 타입스트립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합 (벤 다이어그램)으로 표현 됩니다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있습니다. <br/> 💡 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있습니다. <br/> 💡 타입 연산은 집합의 범위에 적용됩니다, A와 B의 인터섹션은 A의 범위와 B의 범위의 인터섹션입니다. 객체 타입에서는 `A & B`인 값이 A와 B의 속성을 모두 가짐을 의미합니다.. <br/> 💡 `A는B를 상속` === `A는 B에 할당 가능` === `A는B의 서브타입` === `A는B의 부분 집합`, 모두 같은 의미입니다.  |
|  9  | [타입 단언보다는 타입 선언을 사용하기](https://github.com/Pyotato/effective_typescript/blob/item9/README.md) | 💡 타입 단언 `(as Type)`보다는 타입 선언 `(: Type)`를 사용해야 합니다. <br/> 💡 화살표 함수의 반환 타입을 명시하는 방법을 터득해야 합니다. <br/> 💡 타입스크립트보다 타입 정보를 더 잘 알고 있는 상황에서는 타입 단언문보다는 null 아님 단언문을 사용하면 됩니다.  |
|  10  | [객체 래퍼 타입 피하기](https://github.com/Pyotato/effective_typescript/blob/item10/README.md) | 💡 기본형 값에 매서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 합니다. 직접 사용하거나 인스턴스르 생성하는 것은 피해야합니다. <br/> 💡 타입스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야합니다. String 대신 `string`, Number 대신 `number`, Boolean 대신 `boolean`, Symbol 대신 `symbol` BigInt 대신 `bigint`를 사용해야 합니다.  |
|  11  | [잉여 속성 체크의 한계 인지하기](https://github.com/Pyotato/effective_typescript/blob/item11/README.md) | 💡 객체 리터럴을 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행됩니다. <br/> 💡 잉여 속성 체크는 오류를 찾는 효과적인 방법이지만, 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이 다릅니다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있습니다. <br/> 💡 잉여 속성 체크에는 한계가 있습니다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다는 점을 기억해야 합니다.  |



### 3장 : 타입 추론

>

| item |                                                  title                                                  | summary                                                                                                                                                                                                                                                                                             |
| :--: | :-----------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------ |
|  19  | [공식 명칭에는 상표를 붙이기](https://github.com/Pyotato/effective_typescript/blob/item19/README.md) | 💡 타입스크립트가 타입을 추론할 수 있다면 타입 구문을 작성하지 않는게 좋습니다.<br/>  💡 이상적인 경우 함수/메서드의 시그니처에는 타입 구문이 있지만, 함수 내의 지역 변수에는 타입 구문이 없습니다. <br/> 💡 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야합니다. 이는 내부 구현의 오류가 사용자 코드 위치에 나타나는 것을 방지해 줍니다.                                                                  |

### 4장 : 타입 설계

>

| item |                                                  title                                                  | summary                                                                                                                                                                                                                                                                                             |
| :--: | :-----------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------ |
|  37  | [공식 명칭에는 상표를 붙이기](https://github.com/Pyotato/effective_typescript/blob/item37/README.md) | 💡 타입스크립트는 구조적 타이핑(덕 타이핑)을 사용하기 때문에, 값을 세밀하게 구분하지 목하는 경우가 있습니다. 값을 구분하기 위해 공식 명칭이 필요하다면 상표를 붙이는 것을 고려해야합니다. <br/> 💡 상표 기법은 타입 시스템에서 동작하지만 런타임에 상표를 검사하는 것과 동일한 효과를 얻을 수 있습니다.<br/>                                                                                        |

### 5장 : any 다루기

>


| item |                                                  title                                                  | summary                                                                                                                                                                                                                                                                                             |
| :--: | :-----------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------ |
|  40  | [함수 안으로 타입 단언문 감추기](https://github.com/Pyotato/effective_typescript/blob/item40/README.md) | 💡 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 합니다. 불가피하게 사용해야한다면, 정확한 정의를 가지는 함수 안으로 숨기도록 합니다.                                                                                                       |


### 6장 : 타입 선언과 @types

>

| item |                                                  title                                                  | summary                                                                                                                                                                                                                                                                                             |
| :--: | :-----------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------ |


### 7장 : 코드를 작성하고 실행하기

| item |                                                  title                                                  | summary                                                                                                                                                                                                                                                                                             |
| :--: | :-----------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------ |
|  53  |     [타입스크립트 기능보다는 ECMAScript 기능을 사용하기](https://github.com/Pyotato/effective_typescript/blob/item53/README.md)     | 💡 일반적으로 타입스크립트 코드에서 모든 타입 정보를 제거하면 자바스크립트가 되지만, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 타입 정보를 제거한다고 자바스크립트가 되지 않습니다. <br/> 💡 타입스크립트의 역할을 명확하게 하려면, 열거형, 매개변수 속성, 트리플 슬래시 임포트, 데코레이터는 사용하지 않는 것이 좋습니다. |
|  54  |     [객체를 순회하는 노하우](https://github.com/Pyotato/effective_typescript/blob/item54/README.md)     | 💡 객체를 순회할 때, 키가 어떤 타입인지 정확히 파악하고 있다면 `let k : keysof T`와 `for-in` 루프를 사용합시다. 함수의 매개변수로 쓰이는 객체에는 추가적인 키가 존재할 수 있다는 점을 명심합시다. <br/> 💡 객체를 순회하며 키와 값을 얻는 가장 일반적인 방법은 `Object.entries` 를 사용하는 것입니다. |

### 8장 : 타입스크립트로 마이그레이션하기

| item |                                                  title                                                  | summary                                                                                                                                                                                                                                                                                             |
| :--: | :-----------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------ |

